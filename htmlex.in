#! @PERL@
# @configure_input@
#
# htmlex - a powerful hypertext markup language preprocessor
# Copyright (C) 2001 David A. Capello
#
# http://htmlex.sourceforge.net
#

use strict;



# ==========================================================================
# htmlex variables
# ==========================================================================



# the name of the program
my $htmlex = "htmlex"; # __FILE__

# we are reading from the standard input stream?
my $htmlex_using_stdin = 0;

# list of available paths to search all files (default=only '.')
my @htmlex_include = ( '.' );

# the file to be process (default=stdin)
my $htmlex_filename = '';

# list of arguments for the file
my @htmlex_fileargs = ();

# last read line of the input file
my $htmlex_fileline = 0;

# file dependencies
my %htmlex_filedeps = ();

# output dependencies? (default=no)
my $htmlex_dependencies = 0;

# process macros value? (default=yes)
my $htmlex_process_macro = 1;

# preserve HTML comments? (default=no)
my $htmlex_preserve_comments = 0;

# show the HTTP header? (default=no)
my $htmlex_http_header = 0;

# show more information of the process (0=none(default), 1=normal, 2=high)?
my $htmlex_verbose = 0;

# show version? (default=no)
my $htmlex_version = 0;

# show usage? (defualt=no)
my $htmlex_help = 0;

# list of macros
my %htmlex_macro = ();

# characters that are the first character in a macro
my @htmlex_macro_chars = ();

# states of the `if' comparations
#  -1 = if-spaces separator (one space is a independent block of other)
#   0 = not yet enter in the if-block
#   1 = inside the if-block
#   2 = outside the if-block (but we already pass for a if-block)
my @htmlex_if_status = ( -1 ); # define the first if-space

# is allowed print text?
my $htmlex_can_attach = 1;

# usage text
my $htmlex_usage = <<EOT;
Usage:
  $htmlex [ options ] file [ args ]
  $htmlex [ options ] [ -- [ args ] ] < stdin

Compile the FILE (or STDIN) and output the results to the STDOUT.

      --                all next arguments are for the file
  -I, --include <dir>   add <dir> to the end of include paths
  -M, --dependencies    generate make dependencies
  -p, --no-process      don\'t process the macro content in the defition
                        like C/C++ style, warning: this option can cause
                        recursive macros
  -c, --comments        preserve HTML comments in the result
  -n, --number          print all lines with line numbers added
  -t, --http-header     output the HTTP header
  -v, --verbose         explain what is being done
  -V, --very-verbose    explain with a lot of information what is being done
      --help            display this help and exit
      --version         output version information and exit

Report bugs to <dacap\@users.sourceforge.net>.
EOT



# ==========================================================================
# htmlex functions
# ==========================================================================



sub htmlex_exists ($\%);
sub htmlex_refresh ();
sub htmlex_print (\$);
sub htmlex_attach (\$$);
sub htmlex_usage ($);
sub htmlex_getoptions ();
sub htmlex_getargs ($);
sub htmlex_extag (*$$\$);
sub htmlex_process_text (*$$);



# auxiliary function for search a key in a hash table
sub htmlex_exists ($\%)
{
  my $key = shift;
  my $hash = shift;
  return grep ($_ eq $key, keys %$hash);
}



# updates the `htmlex_can_attach' flag
sub htmlex_refresh ()
{
  for (my $c=0; $c<=$#htmlex_if_status; $c++) {
    last if ($htmlex_if_status[$c] == -1);

    # if some previous if-block give false
    if ($htmlex_if_status[$c] != 1) {
      # we can't print text
      $htmlex_can_attach = 0;
      return;
    }
  }

  # we can print text
  $htmlex_can_attach = 1;
}



# print text in the result file
sub htmlex_print (\$)
{
  my $text = shift;

  # print the text
  print STDOUT ($$text) if ((!$htmlex_dependencies) && ($htmlex_can_attach));

  # and delete the text
  $$text = '';
}



# attachs a string to the text-block
sub htmlex_attach (\$$)
{
  my $text = shift;
  my $more = shift;

  $$text .= $more if ($htmlex_can_attach);
}



# shows all the help or the way of how obtain it
sub htmlex_usage ($)
{
  my $code = shift;

  if (!$code) {
    print STDOUT ($htmlex_usage);
  }
  else {
    print STDERR ("Try `$htmlex --help' for more information.\n");
  }

  exit ($code);
}



# gets the options in the arguments
sub htmlex_getoptions ()
{
  my $next_to_args = 0;
  my $next_to_include = 0;
  my $arg;

  # process argument by argument
  foreach $arg (@ARGV) {
    # this parameter is (and all next) an argument for the input file
    if ($next_to_args) {
      $htmlex_fileargs[$#htmlex_fileargs+1] = $arg;
      next;
    }

    # this parameter is a path to `@htmlex_include' array
    if ($next_to_include) {
      $next_to_include = 0;
      $htmlex_include[$#htmlex_include+1] = $arg;
      next;
    }

    # a long option "--..."
    if ($arg =~ /^--/) {
      # next arguments to the htmlex file
      if ($arg eq '--') {
        $next_to_args = 1;
      }
      # new include path
      elsif ($arg eq '--include') {
        $next_to_include = 1;
      }
      elsif ($arg =~ '--include=(.*)') {
        $htmlex_include[$#htmlex_include+1] = $1;
      }
      # generate dependencies
      elsif ($arg eq '--dependencies') {
        $htmlex_dependencies = 1;
      }
      # process the macro value
      elsif ($arg eq '--no-process') {
        $htmlex_process_macro = 0;
      }
      # preserve
      elsif ($arg eq '--comments') {
        $htmlex_preserve_comments = 1;
      }
      # output the http header
      elsif ($arg eq '--http-header') {
        $htmlex_http_header = 1;
      }
      # verbose mode on
      elsif ($arg eq '--verbose') {
        $htmlex_verbose = 1 if ($htmlex_verbose < 1);
      }
      # very verbose mode on
      elsif ($arg eq '--very-verbose') {
        $htmlex_verbose = 2;
      }
      # display the program usage
      elsif ($arg eq '--help') {
        $htmlex_help = 1;
      }
      # display the program version
      elsif ($arg eq '--version') {
        $htmlex_version = 1;
      }
      # error, this option isn't availabled
      else {
        print STDERR ("$htmlex: unrecognized option `$arg'\n");
        htmlex_usage 1;
      }
    }
    # short options "-..."
    elsif ($arg =~ /^-/) {
      my $i;

      # go char-by-char
      for ($i=1; substr ($arg, $i, 1) ne ''; $i++) {
        # get a sub-string of 1 character of length in the `$i' index position
        $_ = substr ($arg, $i, 1);

        # what means this character?
        SWITCH: {
          # -I path
          $next_to_include = 1,
          last SWITCH if (/I/ and (substr ($arg, $i+1, 1) ne '='));

          # -I=path
          $htmlex_include[$#htmlex_include+1] = substr ($arg, $i+2),
          $i += length (substr ($arg, $i+1)),
          last SWITCH if ((/I/) and (substr ($arg, $i+1, 1) eq '='));

          # -M
          $htmlex_dependencies = 1,
          last SWITCH if (/M/);

          # -p
          $htmlex_process_macro = 0,
          last SWITCH if (/p/);

          # -c
          $htmlex_preserve_comments = 1,
          last SWITCH if (/c/);

          # -t
          $htmlex_http_header = 1,
          last SWITCH if (/t/);

          # -v
          $htmlex_verbose = ($htmlex_verbose < 1)? 1: $htmlex_verbose,
          last SWITCH if (/v/);

          # -V
          $htmlex_verbose = 2,
          last SWITCH if (/V/);

          # unknow option
          print STDERR ("$htmlex: invalid option -- $_\n");
          htmlex_usage(1);
        }
      }
    }
    # the input file name
    else {
      # name of the file to open
      $htmlex_filename = $arg;

      # all next arguments for that file
      $next_to_args = 1;
    }
  }
}



# returns an array with all the attributes of the specified
# tag by the string; this string can be something like this:
# value 2ndarg "bla bla" 'more bla'
sub htmlex_getargs ($)
{
  my $string = shift;
  my @args = ();
  my $begin = -1;
  my ($i, $c);

  # proceed while the character will not be the end of the string
  for ($i=0, $c=' '; $c ne ''; $i++) {
    # get a character
    $c = substr ($string, $i, 1);

    # if it not is a space, tab and the final of the string
    if (($c ne ' ') and ($c ne "\t") and ($c ne '')) {
      # count of `<' and `>'
      my $bracket_count = ($c eq '<')? 1: 0;

      # quoted text?
      my $quoted = ($c eq '"')? $c: ($c eq '\'')? $c: '';

      # the beginning of the argument
      $begin = $i;

      # find the final of the argument
      for ($i++; $c ne ''; $i++) {
        # get a character
        $c = substr ($string, $i, 1);

        # count the angular brackets
        $bracket_count++ if ($c eq '<');
        $bracket_count-- if ($c eq '>');

        # is quoted text?
        if ($quoted ne '') {
          # is the character a space? ok, it's the end
          last if ($c eq $quoted);
        }
        # is normal text
        elsif ($bracket_count == 0) {
          # is the character a space or a tab? ok, it's the end
          last if (($c eq ' ') or ($c eq "\t"));
        }
      }

      # fetch the argument (if have a quote, chop the first character)
      $args[$#args+1] = substr ($string,
         $begin+(($quoted)?1:0), $i-$begin-(($quoted)?1:0));
    }
  }

  # print all the array (in very-verbose mode)
  if ($htmlex_verbose > 1) {
    for ($c=0; $c<=$#args; $c++) {
      print STDERR ("$htmlex_filename:$htmlex_fileline: tag argument[$c]: \""
        . $args[$c] . "\"\n");
    }
  }

  # return the array
  return @args;
}



# evaluate a expression (in three arguments)
sub htmlex_eval (\@)
{
  my $args = shift;

  # always false
  if ($#$args < 0) {
    return 0;
  }
  # one argument: false only if the argument if just nil
  elsif ($#$args < 1) {
    return 1 if ($$args[0] ne '');
    return 0;
  }
  # two arguments: the first must be `!'
  elsif ($#$args < 2) {
    if ($$args[0] eq '!') {
      return 1 if ($$args[0] eq '');
      return 0;
    }
  }
  # three arguments: the second must be `==' or `!='
  elsif ($#$args < 3) {
    if ($$args[1] eq '==') {
      return 1 if ($$args[0] eq $$args[2]);
      return 0;
    }
    elsif ($$args[1] eq '!=') {
      return 1 if ($$args[0] ne $$args[2]);
      return 0;
    }
  }

  # error, unknow how process the expression
  die ("$htmlex_filename:$htmlex_fileline: Invalid expresion.\n");
}



# process a htmlex tag (return 0 if the tag is HTML and not html"ex")
sub htmlex_extag (*$$\$)
{
  my $filehandle = shift;
  my $icanread = shift;
  my $tag = shift;
  my $res = shift;

  # all htmlex tag start with "!..."
  if ($tag =~ /^\!([a-zA-Z][a-zA-Z0-9\-]*)(.*)/) {
    # name of the tag (in lower case)
    my $name = lc ($1);

    # get the arguments
    my @args = htmlex_getargs ($2);

    # "args" and "argN"
    if ($name =~ /^arg(s|[0-9]+)$/) {
      if ($1 =~ /s/) {
        htmlex_attach ($$res, $#htmlex_fileargs+1);
      }
      elsif ($1-1 >= 0 and $1-1 <= $#htmlex_fileargs) {
        htmlex_attach ($$res, $htmlex_fileargs[$1-1]);
      }
    }
    # "macro..."
    elsif ($name eq 'macro') {
      # first argument: name of the macro
      if ($#args >= 0) {
        # second argument: value of the macro
        if ($#args >= 1) {
          my $exists = htmlex_exists ($args[0], %htmlex_macro);

          # add the macro
          if ($htmlex_process_macro) {
            # process the macro value
            $htmlex_macro{$args[0]} = htmlex_process_text (*$filehandle, 0, $args[1]);
          }
          else {
            # leave the value intact, it will be processed in the future
            $htmlex_macro{$args[0]} = $args[1];
          }

          # add one macro more that use the first character of its name
          # (if the macro didn't exist)
          $htmlex_macro_chars[ord ($args[0])]++ if (!$exists);

          # a verbose message
          print STDERR ("$htmlex_filename:$htmlex_fileline: "
            . (($exists)? "set": "new") . " macro: \""
            . $args[0] . "\" -> \"" . $htmlex_macro{$args[0]} . "\"\n")
            if ($htmlex_verbose > 0);
        }
        # delete the macro
        else {
          # one macro less with the first character of its name
          $htmlex_macro_chars[ord ($args[0])]--;

          # delete the macro from the hash table
          delete $htmlex_macro{$args[0]};
  
          print STDERR ("$htmlex_filename:$htmlex_fileline: delete macro: \""
            . $args[0] . "\"\n")
            if ($htmlex_verbose > 0);
        }
      }
    }
    # "macro-reset"
    elsif ($name eq 'macro-reset') {
      # reset all macros?
      print STDERR ("$htmlex_filename:$htmlex_fileline: reset all macros\n")
        if ($htmlex_verbose > 0);
  
      %htmlex_macro = ();
      @htmlex_macro_chars = ();
    }
    # "include..."
    elsif ($name eq 'include') {
      # local file (needed for multiple includes)
      local *INCFILE;

      # don't have the necesary arguments (just one is needed)
      return 1 if ($#args < 0);

      # flush the `$res' content
      htmlex_print ($$res) if ($icanread);

      # process all arguments (because they can have some macros and/or tags)
      for (my $c=0; $c<=$#args; $c++) {
        $args[$c] = htmlex_process_text (*$filehandle, 0, $args[$c]);
      }

      # the first argument is the name of the file
      my $filename = $args[0];

      # if the file is nil
      return 1 if ($filename eq '');

      # temporary values
      my ($path, $usedpath, $opened) = ('', '', 0);

      # try to open the file in all posible locations
      foreach $path (@htmlex_include) {
        open (*INCFILE, "$path/$filename") or next;
        $usedpath = $path;
        $opened = 1;
        last;
      }

      # not founded?
      if (!$opened) {
        my $need_attach = 1;

        for (my $c=0; $c<=$#htmlex_if_status; $c++) {
          next if ($htmlex_if_status[$c] == -1);

          # if some previous if-block give false
          if ($htmlex_if_status[$c] != 1) {
            # we don't need print this file
            $need_attach = 0;
            last;
          }
        }

        # the file doesn't exist! (die only if we should print this file)
        die ("$htmlex_filename:$htmlex_fileline: $filename: $!.\n")
          if ($need_attach);
      }
      # all right
      else {
        print STDERR ("$htmlex_filename:$htmlex_fileline: including: \"$usedpath/$filename\"\n")
          if ($htmlex_verbose > 0);
  
        # add a new dependency
        $htmlex_filedeps{"$usedpath/$filename"} = 1 if ($htmlex_dependencies);

        # backup the name, line count and arguments of the file
        my $htmlex_filename_backup = $htmlex_filename;
        my $htmlex_fileline_backup = $htmlex_fileline;
        my @htmlex_fileargs_backup = @htmlex_fileargs;

        # reset the line counter
        $htmlex_filename = "$usedpath/$filename";

        # reset the line counter
        $htmlex_fileline = 0;

        # use new file arguments
        shift @args;
        @htmlex_fileargs = @args;

        # line-by-line
        while (!eof (*INCFILE)) {
          # read a line
          my $line = readline (*INCFILE);

          # count a line
          $htmlex_fileline++;

          # process that line
          $line = htmlex_process_text (*INCFILE, $icanread, $line);

          # if we can read from the file
          if ($icanread) {
            # print the line directly
            htmlex_print ($line);
          }
          else {
            # attach the line to the result
            htmlex_attach ($$res, $line);
          }
        }

        # restore the old name, count and arguments
        $htmlex_filename = $htmlex_filename_backup;
        $htmlex_fileline = $htmlex_fileline_backup;
        @htmlex_fileargs = @htmlex_fileargs_backup;

        # close the file
        close (*INCFILE);
      }
    }
    # "include-path..."
    elsif ($name eq 'include-path') {
      my ($path, $filename);

      # print the list of paths
      if ($#args < 0) {
        foreach $path (@htmlex_include) {
          htmlex_attach ($$res, "$path ");
        }
      }
      # print where the file can be founded
      else {
        # process the first argument only
        $filename = htmlex_process_text (*$filehandle, 0, $args[0]);

        # try to open the file in all posible locations
        foreach $path (@htmlex_include) {
          if (-r "$path/$filename") {
            htmlex_attach ($$res, "$path/$filename");

            print STDERR ("$htmlex_filename:$htmlex_fileline: file founded: \"$path/$filename\"\n")
              if ($htmlex_verbose > 0);
            return 1;
          }
        }

        # error!
        die "$htmlex_filename:$htmlex_fileline: $filename: Not founded in any include path\n";
      }
    }
    # "exec..."
    elsif (($name eq 'exec') or ($name eq 'exec-proc')) {
      # local file (needed for multiple executes)
      local *OUTFILE;

      # don't have the necesary arguments (just one is needed)
      if ($#args < 0) {
        return 1;
      }

      # flush the `$res' content
      htmlex_print ($$res) if ($icanread);

      # command to execute
      my $command = '';

      # process all arguments (because they can have some macros and/or tags)
      for (my $c=0; $c<=$#args; $c++) {
        if ($c == 0) {
          $command .= htmlex_process_text (*$filehandle, 0, $args[$c]);
        }
        else {
          $command .= '"' . htmlex_process_text (*$filehandle, 0, $args[$c]) . '"';
        }

        $command .= ' ';
      }

      # we need to process the STDOUT?
      my $process = ($name eq 'exec-proc');
  
      # redir STDOUT to this file
      my $outfile = '_stdout_.tmp';
  
      # execute the command and output the result to `$outfile'
      system ("$command > \"$outfile\"");
  
      # open the output file
      open (*OUTFILE, $outfile) or die "$htmlex: $outfile: $!\n";
  
      # backup the line count
      my $htmlex_fileline_backup = $htmlex_fileline;
  
      # line-by-line
      while (!eof (*OUTFILE)) {
        # read a line
        my $line = readline (*OUTFILE);

        # process and output that line
        if ($process) {
          # process
          $line = htmlex_process_text (*OUTFILE, $icanread, $line);
  
          # restore the old counter
          $htmlex_fileline = $htmlex_fileline_backup;
        }

        # if we can read from the file
        if ($icanread) {
          # print the line directly
          htmlex_print ($line);
        }
        else {
          # attach the line to the result
          htmlex_attach ($$res, $line);
        }
      }
  
      # close the output file
      close (OUTFILE);
  
      # remove the file
      unlink $outfile;
    }
    # "dir..."
    elsif ($name eq 'dir') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # all text before the last slash
      if ($args[0] =~ /(.*\/).*$/) {
        htmlex_attach ($$res, $1);
      }
      # else, if `args[0]' is a file name without path,
      # put just the current directory
      else {
        htmlex_attach ($$res, './');
      }
    }
    # "notdir..."
    elsif ($name eq 'notdir') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # all text after the last slash (/)
      if ($args[0] =~ /.*\/(.*)$/) {
        htmlex_attach ($$res, $1);
      }
      # if don't have a slash, this means that `args[0]' is
      # a file name without the path
      else {
        htmlex_attach ($$res, $args[0]);
      }
    }
    # "suffix..."
    elsif ($name eq 'suffix') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # first, like <!notdir...>
      if ($args[0] =~ /.*\/(.*)$/) {
        # all text after the last period (.) in the file name
        if ($1 =~ /.*(\..*)$/) {
          htmlex_attach ($$res, $1);
        }
      }
      # `args[0]' is a file name, without a path
      else {
        # all text after the last period (.) in the file name
        if ($args[0] =~ /.*(\..*)$/) {
          htmlex_attach ($$res, $1);
        }
      }
    }
    # "basename..."
    elsif ($name eq 'basename') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # first, like <!notdir...>
      if ($args[0] =~ /.*\/(.*)$/) {
        # the file name (without the path) have a period?
        if ($1 =~ /\./) {
          # remove the extension of the complete path
          if ($args[0] =~ /(.*)\..*$/) {
            htmlex_attach ($$res, $1);
          }
          # don't have extension, put all the path with the file name
          else {
            htmlex_attach ($$res, $args[0]);
          }
        }
        # the file name don't have periods, put all
        else {
          htmlex_attach ($$res, $args[0]);
        }
      }
      # `args[0]' is a file name, without a path
      else {
        # remove the extension of the file name
        if ($args[0] =~ /(.*)\..*$/) {
          htmlex_attach ($$res, $1);
        }
        # don't have extension, put the file name
        else {
          htmlex_attach ($$res, $args[0]);
        }
      }
    }
    # "chop..."
    elsif ($name eq 'chop') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # remove the last character
      chop $args[0];
      htmlex_attach ($$res, $args[0]);
    }
    # "shift..."
    elsif ($name eq 'shift') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # remove the first character
      htmlex_attach ($$res, substr ($args[0], 1)) if ($args[0] ne '');
    }
    # "lc..."
    elsif ($name eq 'lc') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # all to lower case
      htmlex_attach ($$res, lc $args[0]);
    }
    # "lcfirst..."
    elsif ($name eq 'lcfirst') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # the first character to lower case
      htmlex_attach ($$res, lcfirst $args[0]);
    }
    # "uc..."
    elsif ($name eq 'uc') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # the first character to upper case
      htmlex_attach ($$res, uc $args[0]);
    }
    # "ucfirst..."
    elsif ($name eq 'ucfirst') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # the first character to upper case
      htmlex_attach ($$res, ucfirst $args[0]);
    }
    # "if..." and "elif..."
    elsif (($name eq 'if') or ($name eq 'elif')) {
      # flush the `$res' content
      htmlex_print ($$res) if ($icanread);

      # process all arguments
      for (my $c=0; $c<=$#args; $c++) {
        $args[$c] = htmlex_process_text (*$filehandle, 0, $args[$c]);
      }

      # evaluate the expression
      if (htmlex_eval (@args)) {
        # for a true expression...

        # is this tag a `if'?...
        if ($name eq 'if') {
          # `if' = new level of state (1: we are now inside the if-block)
          unshift (@htmlex_if_status, 1);
        }
        # this tag is a `elif'...
        # if we not yet pass for any if-block
        elsif ($htmlex_if_status[0] != 2) {
          # enter in this level
          $htmlex_if_status[0] = 1;
        }
      }
      # the evaluation give false
      else {
        # for a false expression...

        # is this tag a `if'?...
        if ($name eq 'if') {
          # `if' = new level of state (0: but don't enter in this if-block)
          unshift (@htmlex_if_status, 0);
        }
        # this tag is a `elif'...
        # if we are inside of the previous if-block, now we need to jump
        # all to the next `fi' (end of the if-block)
        elsif ($htmlex_if_status[0] == 1) {
          $htmlex_if_status[0] = 2;
        }
      }

      # update $htmlex_can_attach flag
      htmlex_refresh ();
    }
    # "else"
    elsif ($name eq 'else') {
      # if we not yet pass for any if-block
      if ($htmlex_if_status[0] != 2) {
        # if all previous `if' and `elif' give false
        if ($htmlex_if_status[0] == 0) {
          # now, is time to pass for the `else'
          $htmlex_if_status[0] = 1;
        }
        # if the previous `if' or `elif' give true
        else {
          # we need to jump the `else' block
          $htmlex_if_status[0] = 0;
        }
      }

      # update $htmlex_can_attach flag
      htmlex_refresh ();
    }
    # "fi"
    elsif ($name eq 'fi') {
      # back to the old if-level
      shift (@htmlex_if_status);

      # update $htmlex_can_attach flag
      htmlex_refresh ();
    }
    # "htmlex-version"
    elsif ($name eq 'htmlex-version') {
      htmlex_attach ($$res, '@VERSION@');
    }
    # "exists..."
    elsif ($name eq 'exists') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # print the name if the file exists
      htmlex_attach ($$res, $args[0]) if (-e $args[0]);
    }
    # "clean..."
    elsif ($name eq 'clean') {
      my $c;

      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # clean all leading and trailing whitespaces
      for (;;) {
        $c = substr ($args[0], 0, 1);
        if (($c eq ' ') || ($c eq "\n") || ($c eq "\t")) {
          $args[0] = substr ($args[0], 1);
        }
        else {
          last;
        }
      }

      for (;;) {
        $c = substr ($args[0], -1);
        if (($c eq ' ') || ($c eq "\n") || ($c eq "\t")) {
          chop $args[0];
        }
        else {
          last;
        }
      }

      htmlex_attach ($$res, $args[0]);
    }
    # "file-size..."
    elsif ($name eq 'file-size') {
      # process the first argument
      $args[0] = htmlex_process_text (*$filehandle, 0, $args[0]);

      # get the file size in bytes
      my $size = -s $args[0];

      # convert the size to a human-readable format
      my $format;

      if ($size < 1024 * 2) {
        $format = sprintf ("%d", $size);
      }
      elsif ($size < 1024 * 1000) {
        $format = sprintf ("%0.1fk", $size / 1024);
      }
      else {
        $format = sprintf ("%0.2fM", $size / 1024 / 1024);
      }

      htmlex_attach ($$res, $format);
    }
    # this tag isn't defined (or not is a htmlex tag (like <!DOCTYPE ...>))
    else {
      return 0;
    }
  }
  # this tag is HTML (or a invalid tag)
  else {
    return 0;
  }

  # the tag is htmlex
  return 1;
}



# process a block of text
sub htmlex_process_text (*$$)
{
  my $filehandle = shift;
  my $icanread = shift;
  my $line = shift;
  my $res = '';
  my ($i, $c);

  # if we can't read from the file, this signify that we are
  # reading from an argument of some tag
  if (!$icanread) {
    # thereby, we need to create a new if-space
    unshift (@htmlex_if_status, -1);
    htmlex_refresh ();
  }

  # char-by-char
  for ($i=0; substr ($line, $i, 1) ne ''; $i++) {
    # get a character from the line
    $c = substr ($line, $i, 1);

    # is a tag start? ("<...")
    if ($c eq '<') {
      my $buggy_line = $htmlex_fileline;
      my $bracket_count = 1;
      my $tag_string = '';
      my $old_i = $i;

      # is it a comment?
      if (substr ($line, $i, 4) eq '<!--') {
        htmlex_attach ($res, '<') if $htmlex_preserve_comments;

        # jump all text to `-->'
        for (;;) {
          # get one character
          $c = substr ($line, ++$i, 1);

          # print that character?
          htmlex_attach ($res, $c) if $htmlex_preserve_comments;

          # end of the comments?
          if (substr ($line, $i, 3) eq '-->') {
            # print the `->' string
            htmlex_attach ($res, '->') if $htmlex_preserve_comments;

            # jump two remaining characters `-' (the `>' will be
            # skipped in the first `for' of this function)
            $i += 2;
            last;
          }

          # read other line
          if ($c eq '') {
            # is allowed read from the file?
            # doesn't end of file?
            if (($icanread) && (!eof (*$filehandle))) {
              # attach the new line
              $line .= readline (*$filehandle);

              # count a line
              $htmlex_fileline++;

              # back one position
              $i--;
            }
            else {
              die "$htmlex_filename:$buggy_line: Not found the end of comment.\n";
            }
          }
        }
        next;
      }

      # go to the end of the tag ("...>")
      for (; $bracket_count > 0; ) {
        # get the character
        $c = substr ($line, ++$i, 1);

        # brackets control
        $bracket_count++ if ($c eq '<');
        $bracket_count-- if ($c eq '>');

        # attach the character
        $tag_string .= $c;

        # read other line
        if ($c eq '') {
          # is allowed read from the file?
          # doesn't end of file?
          if (($icanread) && (!eof (*$filehandle))) {
            # attach the new line
            $line .= readline (*$filehandle);

            # count a line
            $htmlex_fileline++;

            # back one position
            $i--;
          }
          else {
            die "$htmlex_filename:$buggy_line: Not found the closer bracket.\n";
          }
        }
      }

      # cut the '>' character in the end of the string (if exists)
      chop ($tag_string) if (substr ($tag_string, length ($tag_string)-1) eq '>');

      # replace all newlines ('\n') with spaces (' ')
      $tag_string =~ s/\n/ /gs;

      # tag founded
      print STDERR ("$htmlex_filename:$htmlex_fileline: tag founded: \"$tag_string\"\n")
        if ($htmlex_verbose > 1);

      # is a htmlex tag?
      if (!htmlex_extag(*$filehandle, $icanread, $tag_string, $res)) {
        # no, it's a normal HTML tag...

        # print the angular bracket character
        htmlex_attach ($res, '<');

        # and continue in the first character of the HTML tag
        $i = $old_i;
      }
    }
    # is a normal character and this character is the
    # first character of any macro name
    elsif ($htmlex_macro_chars[ord ($c)] > 0) {
      my ($key, $founded) = ( '', 0 );

      # is the start of a macro?
      foreach $key (sort { length ($b) <=> length ($a) } (keys %htmlex_macro)) {
        if (substr ($line, $i, length ($key)) eq $key) {
          # verbose message
          print STDERR ("$htmlex_filename:$htmlex_fileline: macro founded: \"$key\"\n")
            if ($htmlex_verbose > 0);

          # print the value of the macro
          if ($htmlex_process_macro) {
            # the macro value is ready processed
            htmlex_attach ($res, $htmlex_macro{$key});
          }
          else {
            # the macro value need be processed
            htmlex_attach ($res, htmlex_process_text
              (*$filehandle, 0, $htmlex_macro{$key}));
          }

          # macro founded
          $founded = 1;

          # jump the length of the macro
          $i += length ($key) - 1;

          # stop the iteration
          last;
        }
      }

      # print the character (if it didn't use for the macro)
      htmlex_attach ($res, $c) if (!$founded);
    }
    # is simple characer, print it and continue
    else {
      htmlex_attach ($res, $c);
    }
  }

  # remove the personal if-space
  if (!$icanread) {
    shift (@htmlex_if_status);
    htmlex_refresh ();
  }

  # return the result
  return $res;
}



# ==========================================================================
# htmlex main program body
# ==========================================================================



# get the program options
htmlex_getoptions ();

# process the results of the arguments

# display the usage of the program
if ($htmlex_help) {
  htmlex_usage (0);
}
# display the program name and the actual version number
elsif ($htmlex_version) {
  print STDOUT ('htmlex @VERSION@' . "\n");
  exit (0);
}

# show more information
if ($htmlex_verbose > 1) {
  my $path;

  # all list of paths
  foreach $path (@htmlex_include) {
    print STDERR ("$htmlex: include path: \"$path\"\n");
  }
}

# output the HTTP header
if ($htmlex_http_header) {
  print STDOUT ("Content-type: text/html\n\n") if (!$htmlex_dependencies);
}



# no file, we will read from stdin
if ($htmlex_filename eq '') {
  # we can't make the dependencies of the STDIN
  if ($htmlex_dependencies) {
    die "$htmlex: Can't make dependencies from STDIN\n";
  }

  $htmlex_filename = 'STDIN';

  print STDERR ("$htmlex: reading $htmlex_filename\n")
    if ($htmlex_verbose > 1);

  # pointer to stdin
  *FILE = *STDIN;
  $htmlex_using_stdin = 1;
}
# open the file
else {
  my ($path, $usedpath, $opened) = ('', '', 0);

  # try to open the file in all posible locations
  foreach $path (@htmlex_include) {
    open (*FILE, "$path/$htmlex_filename") or next;
    $usedpath = $path;
    $opened = 1;
    last;
  }

  # not founded?
  if (!$opened) {
    die "$htmlex: $htmlex_filename: $!\n";
  }
  # all right
  else {
    print STDERR ("$htmlex: reading file: \"$usedpath/$htmlex_filename\"\n")
      if ($htmlex_verbose > 1);

    # the file need be closed
    $htmlex_using_stdin = 0;
  }
}



# line-by-line
my ($line, $lineout);
while (!eof (*FILE)) {
  # read a line
  $line = readline (*FILE);

  # count a line
  $htmlex_fileline++;

  # process and output that line
  $lineout = htmlex_process_text (*FILE, 1, $line);

  # print the text
  htmlex_print ($lineout);
}



# generate dependencies
if ($htmlex_dependencies) {
  # file name
  print STDOUT ("$htmlex_filename:");

  # all dependencies
  foreach my $file (keys %htmlex_filedeps) {
    print STDOUT (" \\\n\t$file");
  }

  # end of dependencies
  print STDOUT ("\n\n");
}



# close the file
close (*FILE) if (!$htmlex_using_stdin);

# no errors
exit (0);

